{
    "collab_server" : "",
    "contents" : "# copyright: Xi Wang (xi.wang@dkfz.de)\n\n\n#' Scale gene expression for scGSEA\n#'\n#' This function normalizes single cell gene expression levels acorss cells for each gene. \n#'\n#' @param obj either a `seurat` or a `SingleCellExperiment` object\n#' @param gene_expr_frac fliltering out genes if the non-zero fraction less than this number\n#' @param kNN the k nearest neighbors for data smoothing/denoising. \n#' @return the obj with added data in slot `assay` of `seurat` and `metadata` of `SingleCellExperiment`\n#' @author Xi Wang (xi.wang at dkfz.de)\n#' @example \n#' @export\nscGSEA.scale.data <- function(obj, gene_expr_frac=0.1, kNN=21) { \n  obj.class <- class(obj)\n  stopifnot(obj.class %in% c(\"SingleCellExperiment\", \"seurat\"))\n  if(obj.class == \"seurat\") { \n    data <- as.matrix(obj@data)\n    gene.exp.idx <- apply(data>0, 1, sum) > gene_expr_frac * ncol(data) \n    gene.exp <- data[gene.exp.idx,]\n    if(kNN>0) {\n      if(all(dim(seurat_obj@snn) == ncol(data))) {\n        gene.exp.sm <- do.call(cbind, sapply(1:ncol(gene.exp), function(i) {\n          kNN.w <- tail(sort(obj@snn[i,]), n=(1+kNN))\n          kNN.names <- names(kNN.w)\n          gene.exp[, kNN.names] %*% kNN.w / sum(kNN.w)\n        }, simplify=F))\n        colnames(gene.exp.sm) <- colnames(gene.exp)\n        gene.exp <- gene.exp.sm\n      }\n      else {\n        warning(\"dim of seurat_obj@snn does not match the cell number in the object, kNN is set to 0!\")\n      }\n    }\n    gene.exp.cell_norm <- t(apply(gene.exp, 1, function(x) (x-mean(x))/sqrt(var(x))) )\n    obj@assay$scGSEA.scale.data <- gene.exp.cell_norm\n  }\n  if(obj.class == \"SingleCellExperiment\") {\n    if(kNN>0) {\n      warning(\"kNN>0 is not compatible with sce obj, kNN is set to 0!\")\n    }\n    data <- as.matrix(logcounts(obj))\n    gene.exp.idx <- apply(data>0, 1, sum) > gene_expr_frac * ncol(data) ## Para: expressed in the fraction of cell\n    gene.exp <- data[gene.exp.idx,]\n    gene.exp.cell_norm <- t(apply(gene.exp, 1, function(x) (x-mean(x))/sqrt(var(x))) )\n    metadata(obj)[[\"scGSEA.scale.data\"]] <- gene.exp.cell_norm \n  }\n  return(obj)\n}\n\n#' Get gene list from a `SeqGeneSet` object\n#' \n#' This function extracts a list of genes in geneSet(s) specificed by GeneSetName. \n#' \n#' @param gs.obj a `SeqGeneSet` object\n#' @param GeneSetName Name(s) of geneSet(s)\n#' @return a vector of gene names\n#' @example \n#' @author Xi Wang (xi.wang at dkfz.de) \n#' @export\ngetGSgenelist <- function(gs.obj, GeneSetName) {\n  stopifnot( is(gs_obj, \"SeqGeneSet\") & GeneSetName %in% gs.obj@GSNames )\n  gs.obj@geneList [ gs.obj@GS[[ which( gs.obj@GSNames %in%  GeneSetName ) ]] ]\n} \n\n#' Load and store gene sets for scGSEA\n#' \n#' This function loads gene sets and creats a `SeqGeneSet` object\n#'\n#' @param geneset.file the file path and name of GeneSet in .gmt format \n#' @param sc.obj either a `seurat` or a `SingleCellExperiment` object\n#' @param geneID.type the gene ID type, currently support gene symbol and Ensembl\n#' @param use.HVG logical, using highly variable genes only or not  \n#' @param genesetsize.min minimum number of genes in a gene set, gene set with smaller than this number of genes will be excluded\n#' @param genesetsize.max maximum number of genes in a gene set, gene set with greater than this number of genes will be excluded\n#' @return a `SeqGeneSet` object\n#' @example \n#' @author Xi Wang (xi.wang at dkfz.de) \n#' @export\nscLoadGS <- function(geneset.file, sc.obj, geneID.type = c(\"gene.symbol\", \"ensembl\"), use.HVG=FALSE,\n                     genesetsize.min = 5, genesetsize.max = 1000)  {\n  geneID.type <- match.arg(geneID.type, c(\"gene.symbol\", \"ensembl\"))\n  sc.obj.class <- class(sc.obj)\n  stopifnot(sc.obj.class %in% c(\"SingleCellExperiment\", \"seurat\"))\n  \n  if(use.HVG) {\n    if(sc.obj.class %in% \"seurat\") {\n      genes <- intersect(sc.obj@var.genes, rownames(sc.obj@assay$scGSEA.scale.data))       \n    } else {\n      warning(\"HVG information is not available in sce obj, use.HVG is set FALSE!\")\n    }\n  }\n  else { \n    if(sc.obj.class %in% \"seurat\") { \n      genes <- rownames(sc.obj@assay$scGSEA.scale.data)\n    } else {\n      genes <- rownames(metadata(sc.obj)[[\"scGSEA.scale.data\"]])\n    }\n  }\n  gs <- loadGenesets(geneset.file, genes, geneID.type=geneID.type, singleCell = TRUE, \n                   genesetsize.min=genesetsize.min, genesetsize.max=genesetsize.max)\n  stopifnot(length(gs@GSNames) > 0)\n  gs\n}\n\n#' Calculate ES score\n#' \n#' This function is used to calcuate ES score for each cell and each gene set \n#' \n#' @param sc.obj either a `seurat` or a `SingleCellExperiment` object\n#' @param gs.obj a `SeqGeneSet` object\n#' @param weighted.type the weighted type in GSEA\n#' @return a `SeqGeneSet` object with data added to slot sc.ES \n#' @example \n#' ## Not run: \n#' ## End(Not run)\n#' @author Xi Wang (xi.wang at dkfz.de) \n#' @export\nscCalES <- function(sc.obj, gs.obj, weighted.type = 0) {\n  if( is(sc.obj, \"seurat\") ) {\n    ES <- log10(1+apply(sc.obj@assay$scGSEA.scale.data[gs.obj@geneList, ], 2, function(x) \n      apply(calES(gs.obj, x, weighted.type = weighted.type), 1, max)))\n  }\n  if( is(sc.obj, \"SingleCellExperiment\") ) {\n    ES <- log10(1+apply(metadata(sc.obj)[[\"scGSEA.scale.data\"]][gs.obj@geneList, ], 2, function(x) \n      apply(calES(gs.obj, x, weighted.type = weighted.type), 1, max)))\n  }\n  if(length(gs.obj@GSNames) == 1) { \n    ES <- matrix(ES, nrow=1)\n    rownames(ES) <- gs.obj@GSNames\n  } else { \n    ES <- data.frame(ES, row.names = gs.obj@GSNames)\n  }\n  if( is(sc.obj, \"seurat\") ) {\n    colnames(ES) <- colnames(sc.obj@assay$scGSEA.scale.data)\n  } \n  if( is(sc.obj, \"SingleCellExperiment\") ) {\n    colnames(ES) <- colnames(metadata(sc.obj)[[\"scGSEA.scale.data\"]])\n  } \n  gs.obj@sc.ES <- as.matrix(ES)\n  return(gs.obj)\n}\n\n#' ES score normalizaton \n#' \n#' This function calculates ES scores for a permutated data sets, \n#' which is then used for normalization of the observed ES scores \n#' \n#' @param sc.obj either a `seurat` or a `SingleCellExperiment` object\n#' @param gs.obj a `SeqGeneSet` object\n#' @param weighted.type the weighted type in GSEA\n#' @param perm.time the number of permutations, with default value the number of cells \n#' @return a `SeqGeneSet` object with data added to slot sc.ES.perm and sc.normFlag reset as TRUE\n#' @example \n#' ## Not run: \n#' ## End(Not run)\n#' @author Xi Wang (xi.wang at dkfz.de) \n#' @export\nscESnorm <- function(sc.obj, gs.obj, weighted.type = 0, perm.time=ncol(sc.obj@scale.data)) {\n  if(gs.obj@sc.normFlag) {return(gs.obj)}\n  if(nrow(gs.obj@sc.ES) == 0) { \n    scCalES(sc.obj, gs.obj, weighted.type) \n  }\n  ### calculate ES on shuffled dataset\n  if( is(sc.obj, \"seurat\") ) {\n    gene.exp.shuffled <- t(apply(sc.obj@assay$scGSEA.scale.data[gs.obj@geneList, ], 1, function(x) sample(x)) )\n  }\n  if( is(sc.obj, \"SingleCellExperiment\") ) {\n    gene.exp.shuffled <- t(apply(metadata(sc.obj)[[\"scGSEA.scale.data\"]][gs.obj@geneList, ], 1, function(x) sample(x)) )\n  }\n  ES.shuffled <- log10(1+apply(gene.exp.shuffled, 2, function(x) \n    apply(calES(gs.obj, x, weighted.type = weighted.type), 1, max)))\n  if(length(gs.obj@GSNames) == 1) {\n    ES.shuffled <- matrix(ES.shuffled, nrow=1)\n    rownames(ES.shuffled) <- gs.obj@GSNames\n  } else {\n    ES.shuffled <- data.frame(ES.shuffled, row.names = gs.obj@GSNames)\n  }\n  ES.shuffled.mean <- apply(ES.shuffled, 1, mean)\n  ### normalize ES and ES.shuffled\n  NES <- gs.obj@sc.ES / ES.shuffled.mean\n  NES.shuffled <- ES.shuffled / ES.shuffled.mean\n  gs.obj@sc.ES <- as.matrix(NES)\n  gs.obj@sc.ES.perm <- as.matrix(NES.shuffled)\n  gs.obj@sc.normFlag = TRUE\n  return(gs.obj)\n}\n\n#' Add scGESA results to single cell object\n#' \n#' This functions adds scGESA results to single cell object\n#' \n#' @return a `SeqGeneSet` object with data added to slot sc.ES.perm and sc.normFlag reset as TRUE\n#' @example \n#' ## Not run: \n#' ## End(Not run)\n#' @author Xi Wang (xi.wang at dkfz.de) \n#' @export\nadd.scGESA.to.obj <- function(sc.obj, gs.obj) {\n  stopifnot(gs.obj@sc.normFlag)\n  seurat_obj@dr$scGSEA@cell.embeddings <- t(gs_obj@sc.ES)\n}\n\n\n#' Calculate ES significance\n#' \n#' This function calculates ES significance, including p-value, FDR, and FWER\n#' \n#' @return a `SeqGeneSet` object with data added to slots sc.pval, sc.FDR, and sc.FWER\n#' @example \n#' ## Not run: \n#' ## End(Not run)\n#' @author Xi Wang (xi.wang at dkfz.de) \n#' @export\nscCalSignif <- function(gs.obj) {\n  stopifnot(gs.obj@sc.normFlag)\n  NES <- gs.obj@sc.ES\n  NES.shuffled <- gs.obj@sc.ES.perm\n  NES.shuffled.gs_max <- apply(NES.shuffled, 2, max)\n  shuffle.time <- ncol(NES.shuffled)\n  NES.pval <- apply(NES, 2, function(NES_v) sapply(1:length(NES_v), function(i) sum(NES_v[i] <= NES.shuffled[i,]) / shuffle.time ))\n  NES.FWER <- apply(NES, 2, function(NES_v) sapply(NES_v, function(NES_i) sum(NES_i <= NES.shuffled.gs_max) / shuffle.time ))\n  NES.FDR <- apply(NES, 2, function(NES_v) sapply(NES_v, function(NES_i) {\n    sum( apply(NES_i <= NES.shuffled, 2, sum) ) / sum( apply(NES_i <= NES, 2, sum) ) }))\n  NES.FDR[NES.FDR>1] <- 1\n  gs.obj@sc.pval <- as.matrix(NES.pval)\n  gs.obj@sc.FDR <- as.matrix(NES.FDR)\n  gs.obj@sc.FWER <- as.matrix(NES.FWER)\n  return(gs.obj)\n}\n\n",
    "created" : 1544725319429.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4247665927",
    "id" : "83AA71EB",
    "lastKnownWriteTime" : 1544728516,
    "last_content_update" : 1544728516,
    "path" : "~/Google Drive/scGSEA/scGSEA/R/scGSEA.R",
    "project_path" : "R/scGSEA.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}